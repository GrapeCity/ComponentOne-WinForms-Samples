<Project>

  <PropertyGroup>
    <NotificationEmailUsername Condition="'$(NotificationEmailUsername)'==''">$(Env:NotificationEmailUsername)</NotificationEmailUsername>
    <NotificationEmailPassword Condition="'$(NotificationEmailPassword)'==''">$(Env:NotificationEmailPassword)</NotificationEmailPassword>
  </PropertyGroup>

  <Target Name="FindDotNetHostPath">

    <Exec Command="where dotnet"
          ConsoleToMsBuild="true">
      <Output TaskParameter="ConsoleOutput" PropertyName="DotNetHostPath"/>
    </Exec>

    <Error Text="Error: 'dotnet' not found." Condition="'$(DotNetHostPath)' == '' Or Exists('$(DotNetHostPath)') == false" />

    <PropertyGroup>
      <DotNetHostPath>&quot;$(DotNetHostPath)&quot;</DotNetHostPath>
    </PropertyGroup>

  </Target>

  <UsingTask TaskName="PackSignBatches" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <InputFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <MaxLength ParameterType="System.Int32" />
      <Batches ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="Microsoft.Build.Framework" />
      <Using Namespace="Microsoft.Build.Utilities" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
        
        const int DEFAULT_MAX = 4000;
        int limit = MaxLength > 0 ? MaxLength : DEFAULT_MAX;

        var batches = new List<ITaskItem>();
        if (InputFiles == null || InputFiles.Length == 0)
        {
            Batches = Array.Empty<ITaskItem>();
            return true;
        }

        string current = string.Empty;
        foreach (var it in InputFiles)
        {
            var path = it?.ItemSpec?.Trim();
            if (string.IsNullOrEmpty(path)) continue;
            if (!File.Exists(path)) continue;

            var quoted = "\"" + path.Replace("\"", "") + "\"";

            if (string.IsNullOrEmpty(current))
            {
                current = quoted;
            }
            else if (current.Length + 1 + quoted.Length <= limit)
            {
                current += " " + quoted;
            }
            else
            {
                batches.Add(new TaskItem(current));
                current = quoted;
            }
        }

        if (!string.IsNullOrEmpty(current))
        {
            batches.Add(new TaskItem(current));
        }

        Batches = batches.ToArray();
        
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="RunDotNetToolWithRestore" DependsOnTargets="FindDotNetHostPath">
    <PropertyGroup>
      <RunCmd>$(DotNetHostPath) tool run $(DotNetToolCommand) $(DotNetToolArguments)</RunCmd>
      <InstallVersionArgument Condition="'$(DotNetToolVersion)' != ''">--version $(DotNetToolVersion)</InstallVersionArgument>
      <InstallCmd>$(DotNetHostPath) tool install --local $(DotNetToolPackageId) $(InstallVersionArgument) --create-manifest-if-needed</InstallCmd>
    </PropertyGroup>

    <Exec Command="$(RunCmd)" IgnoreExitCode="true">
      <Output TaskParameter="ExitCode" PropertyName="ToolExitCode1" />
    </Exec>

    <Exec Command="$(DotNetHostPath) tool restore"
          Condition="'$(ToolExitCode1)' != '0'"
          IgnoreExitCode="true">
      <Output TaskParameter="ExitCode" PropertyName="RestoreExitCode" />
    </Exec>

    <Exec Command="$(RunCmd)"
          Condition="'$(ToolExitCode1)' != '0'"
          IgnoreExitCode="true">
      <Output TaskParameter="ExitCode" PropertyName="ToolExitCode2" />
    </Exec>

    <Exec Command="$(InstallCmd)"
          Condition="'$(ToolExitCode1)' != '0' and '$(ToolExitCode2)' != '0'"
          IgnoreExitCode="true">
      <Output TaskParameter="ExitCode" PropertyName="InstallExitCode" />
    </Exec>

    <Exec Command="$(RunCmd)" Condition="'$(ToolExitCode1)' != '0' and '$(ToolExitCode2)' != '0'" />

  </Target>

  <Target Name="SignBuildArtifacts"
          AfterTargets="AfterBuild"
          Condition="('$(OutputType)' == 'Library' Or '$(OutputType)' == 'Exe' Or '$(OutputType)' == 'WinExe') And '$(SignDigitalSignature)' == 'true'">

    <ItemGroup>
      <BinaryToSign Include="@(FileWrites->WithMetadataValue('Extension', '.dll'));@(FileWrites->WithMetadataValue('Extension', '.exe'))" />
      <VsixToSign Include="@(FileWrites->WithMetadataValue('Extension', '.vsix'))" />
    </ItemGroup>

    <ItemGroup>
      <BinaryToSign Remove="@(BinaryToSign)" Condition="!$([System.String]::Copy('%(BinaryToSign.FullPath)').StartsWith('$(TargetDir)'))" />
      <VsixToSign Remove="@(VsixToSign)" Condition="!$([System.String]::Copy('%(VsixToSign.FullPath)').StartsWith('$(TargetDir)'))" />
    </ItemGroup>

    <Error Text="Certificate property must be set for signing build artifacts"
           Condition="'$(Certificate)' == '' and ('@(BinaryToSign)' != '' Or '@(VsixToSign)' != '')" />

    <PackSignBatches InputFiles="@(BinaryToSign)" Condition="'@(BinaryToSign)' != ''">
      <Output TaskParameter="Batches" ItemName="BinaryBatchToSign" />
    </PackSignBatches>

    <MSBuild Projects="$(MSBuildProjectFile)"
             Targets="RunDotNetToolWithRestore"
             Condition="'%(BinaryBatchToSign.Identity)' != ''"
             Properties="DotNetToolCommand=$(AzureSignToolCommand);DotNetToolPackageId=$(AzureSignToolPackageId);DotNetToolArguments=sign --skip-signed $(Certificate) %(BinaryBatchToSign.Identity);DotNetToolVersion=$(AzureSignToolVersion)" />

  </Target>

  <UsingTask TaskName="GetAssemblyFileVersion" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
    <ParameterGroup>
      <AssemblyPath ParameterType="System.String" Required="true" />
      <AssemblyVersion ParameterType="System.String" Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.Diagnostics" />
      <Using Namespace="System.IO" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
        
        AssemblyVersion = string.Empty;
        
        string assemblyPath = Path.GetFullPath(AssemblyPath);
        if (Path.GetExtension(assemblyPath) != ".dll")
        {
            return false;
        }
        
        if (!File.Exists(assemblyPath))
        {
            return false;
        }
                
        FileVersionInfo versionInfo = FileVersionInfo.GetVersionInfo(assemblyPath);     
        AssemblyVersion = versionInfo.FileVersion.ToString();
        
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="ZipBinariesFolder" Condition="'$(SourceFolder)'!='' And '$(AssemblyForVersionFolder)' != '' And '$(AssemblyPrefix)' != '' And '$(DestinationFolder)'!='' And '$(ZipFilePrefix)'!=''">

    <ItemGroup>
      <Dlls Include="$(AssemblyForVersionFolder)\**\*.dll" />
    </ItemGroup>

    <PropertyGroup>
      <AssemblyForVesionPath Condition="$([System.Text.RegularExpressions.Regex]::IsMatch('%(Dlls.Filename)', '^$(AssemblyPrefix)\.[0-9][0-9\.]*$'))">%(Dlls.FullPath)</AssemblyForVesionPath>
    </PropertyGroup>

    <GetAssemblyFileVersion
      AssemblyPath="$(AssemblyForVesionPath)">
      <Output TaskParameter="AssemblyVersion" PropertyName="AssemblyVersion" />
    </GetAssemblyFileVersion>

    <MakeDir Directories="$(DestinationFolder)" />

    <ZipDirectory SourceDirectory="$(SourceFolder)" DestinationFile="$(DestinationFolder)$(ZipFilePrefix)_$(AssemblyVersion)$(FileSuffix).zip" Overwrite="true" />

  </Target>

  <UsingTask TaskName="SendNotificationEmail" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
    <ParameterGroup>
      <OutputFolderFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <TeamCityBuildId ParameterType="System.String" Required="true" />
      <EmailProductVersion ParameterType="System.String" Required="true" />
      <EmailSubjectSuffix ParameterType="System.String" />
      <NotificationEmailUsername ParameterType="System.String" Required="true" />
      <NotificationEmailPassword ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.Diagnostics" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Net" />
      <Using Namespace="System.Net.Mail" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
        
        string buildlog = "<body><style>h1, h2 {font-size: 1.2rem} h1:first-child::before {content: 'Change log '} body { max-width:720px; margin: 0 auto 0 auto; background: #cfd8dc; color: #000;  font-family: 'Poppins', sans-serif; } h2 {color: #050505}</style>";
        
        buildlog += $"<h2><a href='https://ci.grapecitydev.com/viewLog.html?buildId={TeamCityBuildId}&tab=artifacts'>Dropped Files:</a></h2><ul>";

        foreach (ITaskItem file in OutputFolderFiles)
        {
            buildlog += $"<li>{Path.GetFileName(file.ItemSpec)}</li>";
        }
        buildlog += "</ul>";
        
        string body = $"<html><head></head>{buildlog}</body></html>";

        string smtpServer = "smtp.sendgrid.net";
        int smtpPort = 587;
        string smtpUsername = NotificationEmailUsername;
        string smtpPassword = NotificationEmailPassword;

        MailMessage mail = new MailMessage();
        mail.From = new MailAddress("tcmail@developertools.com", "TeamCity AutoMail");
        mail.To.Add(new MailAddress("c1.dev@developertools.com"));
        string emailSubjectSuffix = string.IsNullOrEmpty(EmailSubjectSuffix) ? string.Empty : EmailSubjectSuffix;
        mail.Subject = $"[drop] C1WinForms Demos {EmailProductVersion} {emailSubjectSuffix}";
        mail.Body = body;
        mail.IsBodyHtml = true;

        SmtpClient smtp = new SmtpClient(smtpServer, smtpPort);
        smtp.UseDefaultCredentials = false;
        smtp.Credentials = new NetworkCredential(smtpUsername, smtpPassword);
        smtp.EnableSsl = true;
        smtp.Send(mail);
        
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="SendBuildNotification" Condition="'$(AssemblyForVersionFolder)' != '' And '$(AssemblyPrefix)' != '' And '$(DroppedFilesFolder)'!=''">

    <ItemGroup>
      <Dlls Include="$(AssemblyForVersionFolder)\**\*.dll" />
    </ItemGroup>

    <PropertyGroup>
      <AssemblyForVesionPath Condition="$([System.Text.RegularExpressions.Regex]::IsMatch('%(Dlls.Filename)', '^$(AssemblyPrefix)\.[0-9][0-9\.]*$'))">%(Dlls.FullPath)</AssemblyForVesionPath>
    </PropertyGroup>
    
    <GetAssemblyFileVersion
      AssemblyPath="$(AssemblyForVesionPath)">
      <Output TaskParameter="AssemblyVersion" PropertyName="AssemblyVersion" />
    </GetAssemblyFileVersion>

    <PropertyGroup>
      <TeamCityBuildId Condition="'$(TeamCityBuildId)'==''">0</TeamCityBuildId>
      <EmailProductVersion>$([System.Text.RegularExpressions.Regex]::Replace('$(AssemblyVersion)', '^\d+\.', ''))</EmailProductVersion>
    </PropertyGroup>

    <ItemGroup>
      <OutputFolderFile Include="$(DroppedFilesFolder)\**\*" />
    </ItemGroup>

    <SendNotificationEmail
      OutputFolderFiles="@(OutputFolderFile)"
      TeamCityBuildId="$(TeamCityBuildId)"
      EmailProductVersion="$(EmailProductVersion)"
      EmailSubjectSuffix="$(CommonSuffix)"
      NotificationEmailUsername="$(NotificationEmailUsername)"
      NotificationEmailPassword="$(NotificationEmailPassword)" />

  </Target>

</Project>